import moment from "moment";
import {
  openedProspectIdState,
  openedBumpFameworksState,
  selectedBumpFrameworkState,
  currentConvoLiMessageState,
  currentConvoChannelState,
  currentConvoEmailMessageState,
  fetchingProspectIdState,
  tempHiddenProspectsState,
  selectedEmailSequenceStepState,
  selectedEmailThread,
  bumpFrameworkSelectedSubstatusState,
  selectedEmailReplyFrameworkState,
} from "@atoms/inboxAtoms";
import { userTokenState } from "@atoms/userAtoms";
import { openConfirmModal } from "@mantine/modals";
import {
  Paper,
  Flex,
  Textarea,
  Text,
  Button,
  useMantineTheme,
  Group,
  ActionIcon,
  LoadingOverlay,
  Tooltip,
  Select,
  Box,
  Popover,
} from "@mantine/core";
import { getHotkeyHandler } from "@mantine/hooks";
import { hideNotification, showNotification } from "@mantine/notifications";
import {
  IconExternalLink,
  IconWriting,
  IconSend,
  IconChevronUp,
  IconChevronDown,
  IconSettings,
  IconArrowsDiagonalMinimize2,
  IconClock,
  IconArrowUp,
  IconCalendar,
  IconZzz,
  IconHourglass,
  IconX,
  IconPencil,
} from "@tabler/icons";
import {
  IconClock24,
  IconMessage2Cog,
  IconSettingsFilled,
  IconWand,
  IconMessageDots,
} from "@tabler/icons-react";
import { useQueryClient } from "@tanstack/react-query";
import { deleteAutoBumpMessage } from "@utils/requests/autoBumpMessage";
import { sendLinkedInMessage } from "@utils/requests/sendMessage";
import _, { debounce, get, set } from "lodash";
import {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";
import { useRecoilState, useRecoilValue } from "recoil";
import {
  BumpFramework,
  EmailReplyFramework,
  EmailSequenceStep,
  EmailThread,
  LinkedInMessage,
  Prospect,
} from "src";
import {
  generateAIEmailReply,
  generateAIFollowup,
} from "./InboxProspectConvoBumpFramework";
import AutoBumpFrameworkInfo from "@common/prospectDetails/AutoBumpFrameworkInfo";
import { ratio as fuzzratio } from "fuzzball";
import { sendEmail } from "@utils/requests/sendEmail";
import RichTextArea from "@common/library/RichTextArea";
import TextAreaWithAI from "@common/library/TextAreaWithAI";
import { JSONContent } from "@tiptap/react";
import DOMPurify from "dompurify";
import { postGenerateFollowupEmail } from "@utils/requests/emailMessageGeneration";
import { API_URL } from "@constants/data";
import { Calendar, DateTimePicker, TimeInput } from "@mantine/dates";
import { updateChannelStatus } from "@common/prospectDetails/ProspectDetailsChangeStatus";
import postSmartleadReply from "@utils/requests/postSmartleadReply";
import { convertToTitleCase } from "@utils/stringFormatting";
import { postGenerateEmailReplyUsingFramework } from "@utils/requests/emailReplies";
import { getBumpFrameworks } from '@utils/requests/getBumpFrameworks';

export default forwardRef(function InboxProspectConvoSendBox(
  props: {
    prospectId: number;
    linkedin_public_id: string;
    email: string;
    nylasMessageId?: string;
    scrollToBottom?: () => void;
    msgLoading?: boolean;
    minimizedSendBox: () => void;
    currentSubstatus?: string;
    triggerGetSmartleadProspectConvo?: () => void;
    archetypeId?: number;
  },
  ref
) {
  useImperativeHandle(
    ref,
    () => {
      return {
        getAiGenerated: () => aiGenerated,
        setAiGenerated: setAiGenerated,
        getMessageDraft: () => messageDraft,
        setMessageDraft: (
          msg: string,
          bumpFramework?: {
            description?: string;
            id?: number;
            length?: string;
            title?: string;
          },
          accountResearch?: string[]
        ) => {
          // bumpFramework is no longer used because we want to show default bump framework and NOT the autogenerated one
          setMessageDraft(msg);
          if (accountResearch) {
            setBumpFramework((prev) => {
              if (!prev) {
                return prev;
              }
              return {
                ...prev,
                account_research: accountResearch,
              };
            });
          }
        },
        setAiMessage: (msg: string) => {
          setAiMessage(msg);
        },
        setBumpFrameworks: (bumpFrameworks: BumpFramework[]) => {
          setBumpFrameworks(bumpFrameworks);

          // Set the default bump framework
          // if (!selectedBumpFramework?.id) {
          //   if (bumpFrameworks.length > 0) {
          //     setBumpFramework(bumpFrameworks[0]);
          //     for (let i = 0; i < bumpFrameworks.length; i++) {
          //       if (bumpFrameworks[i].default) {
          //         setBumpFramework(bumpFrameworks[i]);
          //         break;
          //       }
          //     }
          //   }
          // }
        },
        setEmailReplyFrameworks: (
          emailReplyFrameworks: EmailReplyFramework[]
        ) => {
          // Only set the sequence step to the selected substatus
          setEmailReplyFrameworks(emailReplyFrameworks);
          // Set the default bump framework
          // if (emailReplyFrameworks.length > 0) {
          //   setEmailSequenceStep(emailReplyFrameworks[0]);
          //   for (let i = 0; i < emailReplyFrameworks.length; i++) {
          //     if (emailReplyFrameworks[i].default) {
          //       setEmailSequenceStep(emailReplyFrameworks[i]);
          //       break;
          //     }
          //   }
          // }
        },
      };
    },
    []
  );

  const theme = useMantineTheme();
  const queryClient = useQueryClient();
  const userToken = useRecoilValue(userTokenState);
  const [scheduleDay, setScheduleDay] = useState<Date | undefined>(undefined);
  const [showSchedulePopup, setShowSchedulePopup] = useState(false);
  const [snoozeDay, setSnoozeDay] = useState(
    moment(new Date()).add(4, "days").toDate()
  );
  const openedProspectId = useRecoilValue(openedProspectIdState);
  const openedOutboundChannel = useRecoilValue(currentConvoChannelState);
  const [fetchingProspectId, setFetchingProspectId] = useRecoilState(
    fetchingProspectIdState
  );
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [openBumpFrameworks, setOpenBumpFrameworks] = useRecoilState(
    openedBumpFameworksState
  );
  const [setOpenBumpFrameworksSubstatus, setSetOpenBumpFrameworksSubstatus] =
    useRecoilState(bumpFrameworkSelectedSubstatusState);
  const [selectedBumpFramework, setBumpFramework] = useRecoilState(
    selectedBumpFrameworkState
  ); // LinkedIn
  const [selectedEmailReplyFramework, setEmailReplyFramework] = useRecoilState(
    selectedEmailReplyFrameworkState
  ); // Email
  const [currentConvoLiMessages, setCurrentConvoLiMessages] = useRecoilState(
    currentConvoLiMessageState
  );
  const [currentConvoEmailMessages, setCurrentConvoEmailMessages] =
    useRecoilState(currentConvoEmailMessageState);
  const [currentConvoEmailThread, setCurrentConvoEmailThread] =
    useRecoilState(selectedEmailThread);

  const [tempHiddenProspects, setTempHiddenProspects] = useRecoilState(
    tempHiddenProspectsState
  );

  const [bumpFrameworks, setBumpFrameworks] = useState<BumpFramework[]>([]);
  const [emailReplyFrameworks, setEmailReplyFrameworks] = useState<
    EmailReplyFramework[]
  >([]);
  const [replyLabel, setReplyLabel] = useState(props.currentSubstatus);
  // We use this to store the value of the text area
  const [messageDraft, _setMessageDraft] = useState("");
  // We use this to store the raw value of the rich text editor
  const messageDraftRichRaw = useRef<JSONContent | string>();

  // We use this to set the value of the text area (for both rich text and normal text)
  const setMessageDraft = (value: string) => {
    messageDraftRichRaw.current = value;
    _setMessageDraft(value);
  };
  // For email we have to use this ref instead, otherwise the textbox does a weird refocusing.
  const messageDraftEmail = useRef("");

  const [aiMessage, setAiMessage] = useState("");
  const [aiGenerated, setAiGenerated] = useState(false);
  const [msgLoading, setMsgLoading] = useState(props.msgLoading || false);

  const sendMessage = async () => {
    setMsgLoading(true);

    // Delete the auto bump message if it exists
    await deleteAutoBumpMessage(userToken, props.prospectId);

    // Hack to update the prospect list to temp show they're in purgatory
    setTempHiddenProspects(tempHiddenProspects.concat([props.prospectId]));

    if (openedOutboundChannel === "LINKEDIN") {
      const msg = messageDraft;
      setMessageDraft("");
      showNotification({
        id: "send-linkedin-message",
        title: scheduleDay ? "Scheduling message..." : "Sending message ...",
        message: "",
        color: "green",
        autoClose: 3000,
      });
      setTimeout(() => setFetchingProspectId(-1), 15000);

      setFetchingProspectId(openedProspectId);
      sendLinkedInMessage(
        userToken,
        props.prospectId,
        msg,
        aiGenerated,
        undefined,
        selectedBumpFramework?.id,
        selectedBumpFramework?.title,
        selectedBumpFramework?.description,
        selectedBumpFramework?.bump_length,
        selectedBumpFramework?.account_research,
        snoozeDay,
        scheduleDay
      ).then(() => {
        queryClient.refetchQueries({
          queryKey: [
            `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
          ],
        });
      });
      if (true) {
        let yourMessage = _.cloneDeep(currentConvoLiMessages || [])
          .reverse()
          .find((msg) => msg.connection_degree === "You");
        if (yourMessage) {
          yourMessage.message = msg;
          yourMessage.date = new Date().toUTCString();
          yourMessage.ai_generated = false;
          setCurrentConvoLiMessages([
            ...(currentConvoLiMessages || []),
            yourMessage,
          ]);
        } else {
          queryClient.refetchQueries({
            queryKey: [
              `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
            ],
          });
        }
        showNotification({
          id: "send-linkedin-message",
          title: scheduleDay ? "Message Scheduled" : "Message Sent",
          message: "",
          color: "green",
        });
      } else {
        showNotification({
          id: "send-linkedin-message-error",
          title: "Error",
          message: "Failed to send message. Please try again later.",
          color: "red",
          autoClose: false,
        });
      }
    } else if (openedOutboundChannel === "SMARTLEAD") {
      const prospectid = props.prospectId;
      const response = await postSmartleadReply(
        userToken,
        prospectid,
        messageDraftEmail.current,
        scheduleDay
      );
      if (response.status !== "success") {
        showNotification({
          title: "Error",
          message: "Failed to send email",
          color: "red",
        });
      } else {
        if (scheduleDay) {
          showNotification({
            title: "Success",
            message: "Email scheduled to send.",
            color: "green",
          });
        } else {
          showNotification({
            title: "Success",
            message:
              "Email sent. It may take a few minutes to appear in your inbox.",
            color: "green",
          });
        }

        setMessageDraft("");
      }
      if (props?.triggerGetSmartleadProspectConvo) {
        props?.triggerGetSmartleadProspectConvo();
      }
      setScheduleDay(undefined);
    } else {
      if (
        currentConvoEmailMessages === undefined ||
        currentConvoEmailMessages.length === 0
      ) {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Please select an email thread",
          color: "red",
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }
      const msg = messageDraftEmail.current;
      if (msg.length === 0) {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Please enter a message",
          color: "red",
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }

      // Get the last message
      const replyToMessageID =
        currentConvoEmailMessages[currentConvoEmailMessages.length - 1]
          .nylas_message_id;
      const result = await sendEmail(
        userToken,
        props.prospectId,
        `Re: ${currentConvoEmailThread?.subject}`,
        msg,
        aiGenerated,
        replyToMessageID
      );
      if (result.status === "success") {
        let yourMessage = _.cloneDeep(currentConvoEmailMessages || [])
          .reverse()
          .find((msg) => msg.from_sdr);
        if (yourMessage) {
          yourMessage.body = msg;
          yourMessage.date_received = new Date().toUTCString();
          yourMessage.ai_generated = false;
          setCurrentConvoEmailMessages([
            ...(currentConvoEmailMessages || []),
            yourMessage,
          ]);
        } else {
          queryClient.refetchQueries({
            queryKey: [
              `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
            ],
          });
        }
        messageDraftEmail.current = "";
        messageDraftRichRaw.current = "";
        setMessageDraft("");
      } else {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Failed to send message. Please try again later.",
          color: "red",
          autoClose: false,
        });
      }
    }

    setMsgLoading(false);
    setAiGenerated(false);
    setTimeout(() => props.scrollToBottom && props.scrollToBottom(), 100);
  };

  // If messageDraft is cleared, odds are that the AI generated message was cleared, and the new message is likely not to be AI generated
  useEffect(() => {
    checkFuzz(messageDraft, aiMessage);
  }, [messageDraft, aiMessage]);

  const checkFuzz = useCallback(
    debounce((message, aiMessage) => {
      const ratio = fuzzratio(message, aiMessage);
      // ratio > 5 && setAiGenerated(true);
      // ratio <= 5 && setAiGenerated(false);
      setAiGenerated(true);
    }, 200),
    []
  );

  useEffect(() => {
    (async () => {
      const result = await getBumpFrameworks(
        userToken, 
        // status
        ['ACTIVE_CONVO'],
        [], 
        [],
        undefined,
        undefined,
        undefined,
        props.archetypeId,
      );

      let bumpFrameworkArray = [] as BumpFramework[];
      for (const bumpFramework of result.data.bump_frameworks as BumpFramework[]) {
        if (bumpFramework.default) {
          bumpFrameworkArray.unshift(bumpFramework);
        } else {
          bumpFrameworkArray.push(bumpFramework);
        }
      }

      setBumpFrameworks(bumpFrameworkArray);
      setBumpFramework(bumpFrameworkArray.length > 0 ? bumpFrameworkArray[0] : undefined);
    })()
  }, [
    props.prospectId,
  ])

  const smartGenerate = async (additional_instructions: string) => {
    setMsgLoading(true);
    if (openedOutboundChannel === "LINKEDIN") {
      const result = fetch(
        `${API_URL}/li_conversation/prospect/generate_smart_response`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${userToken}`,
          },
          body: JSON.stringify({
            prospect_id: props.prospectId,
            additional_instructions: additional_instructions,
          }),
        }
      )
        .then((res) => res.json())
        .then((j) => {
          const message = j["message"];

          setMessageDraft(message);
          setAiMessage(message);
          setBumpFramework(j["bump_framework"]);
          setAiGenerated(true);

          showNotification({
            id: "generate-linkedin-message",
            title: "Generated message",
            message: "",
            color: "green",
            autoClose: 3000,
          });
        })
        .catch((e) => {
          showNotification({
            id: "generate-linkedin-message-error",
            title: "Error",
            message: "Failed to generate message",
            color: "red",
            autoClose: 3000,
          });
        })
        .finally(() => {
          setMsgLoading(false);
        });
    }
  };

  useEffect(() => {
    if (replyLabel !== props.currentSubstatus) {
      setReplyLabel(props.currentSubstatus);
    }
  }, [props.currentSubstatus]);

  const replyLabels = useMemo(() => {
    const labels = [
      "ACTIVE_CONVO_QUESTION",
      "ACTIVE_CONVO_QUAL_NEEDED",
      "ACTIVE_CONVO_OBJECTION",
      "ACTIVE_CONVO_SCHEDULING",
      "ACTIVE_CONVO_NEXT_STEPS",
      "ACTIVE_CONVO_REVIVAL",
      "ACTIVE_CONVO_CIRCLE_BACK",
      "ACTIVE_CONVO_REFERRAL",
      "ACTIVE_CONVO_QUEUED_FOR_SNOOZE",
      "ACTIVE_CONVO_CONTINUE_SEQUENCE",
    ];

    return Array.from(labels);
  }, [bumpFrameworks]);

  const labelEmoji = (label: string) => {
    switch (label) {
      case "ACTIVE_CONVO_QUESTION":
        return "❓";
      case "ACTIVE_CONVO_QUAL_NEEDED":
        return "👍";
      case "ACTIVE_CONVO_OBJECTION":
        return "👆";
      case "ACTIVE_CONVO_SCHEDULING":
        return "📆";
      case "ACTIVE_CONVO_NEXT_STEPS":
        return "➡️";
      case "ACTIVE_CONVO_REVIVAL":
        return "🏥";
      case "ACTIVE_CONVO_CIRCLE_BACK":
        return "🔄";
      case "ACTIVE_CONVO_REFERRAL":
        return "👥";
      case "ACTIVE_CONVO_QUEUED_FOR_SNOOZE":
        return "💤";
      case "ACTIVE_CONVO_CONTINUE_SEQUENCE":
        return "";
      default:
        return "";
    }
  };

  const filteredFrameworkData =
    openedOutboundChannel === "LINKEDIN"
      ? bumpFrameworks.length > 0
        ? bumpFrameworks
            .sort((a: BumpFramework, b: BumpFramework) => {
              return a.title.localeCompare(b.title);
            })
            .filter((i) => {
              if (
                !replyLabel &&
                replyLabel !== "ACTIVE_CONVO_CONTINUE_SEQUENCE"
              ) {
                return i;
              }

              if (replyLabel === "ACTIVE_CONVO_CONTINUE_SEQUENCE") {
                return (
                  i.overall_status === "ACCEPTED" ||
                  i.overall_status === "BUMPED"
                );
              }

              return i.substatus === replyLabel;
            })
            .map((bf: BumpFramework) => {
              let title = bf.title;
              if (
                bf.overall_status === "ACCEPTED" ||
                bf.overall_status === "BUMPED"
              ) {
                title =
                  "(step #" +
                  (bf.bumped_count ? bf.bumped_count + 1 : 1) +
                  ") " +
                  bf.title;
              }

              return {
                value: bf.id + "",
                label: title,
              };
            })
        : []
      : emailReplyFrameworks?.length > 0
      ? emailReplyFrameworks
          .sort((a: EmailReplyFramework, b: EmailReplyFramework) => {
            return a.title.localeCompare(b.title);
          })
          .filter((i) => {
            if (!replyLabel) {
              return i;
            }
            return i.substatus === replyLabel;
          })
          .map((step: EmailReplyFramework) => {
            return {
              value: step.id + "",
              // label: (step.default ? "🟢 " : "⚪️ ") + step.title,
              label: step.title,
            };
          })
      : [];

  return (
    <Paper
      shadow="sm"
      withBorder
      radius={theme.radius.md}
      sx={{
        display: "flex",
        flexDirection: "column",
        flexWrap: "nowrap",
        position: "relative",
      }}
      pb={8}
      mah={500}
    >
      <LoadingOverlay visible={msgLoading} />
      <div
        style={{
          flexBasis: "15%",
          backgroundColor: "#25262b",
          borderTopLeftRadius: theme.radius.md,
          borderTopRightRadius: theme.radius.md,
        }}
      >
        <Group spacing={0} position="apart">
          <Flex wrap="nowrap" align="center">
            <Text color="white" fz={14} fw={500} pl={15} pt={5}>
              {openedOutboundChannel === "LINKEDIN"
                ? "Message via LinkedIn"
                : "Reply via Email"}
            </Text>
            <Text
              pl={10}
              pt={5}
              size="xs"
              fs="italic"
              color="gray.3"
              component="a"
              target="_blank"
              rel="noopener noreferrer"
              href={
                openedOutboundChannel === "LINKEDIN"
                  ? `https://www.linkedin.com/in/${props.linkedin_public_id}`
                  : `mailto:${props.email}`
              }
            >
              {openedOutboundChannel === "LINKEDIN"
                ? `linkedin.com/in/${_.truncate(props.linkedin_public_id, {
                    length: 20,
                  })}`
                : props.email}{" "}
              <IconExternalLink size="0.65rem" />
            </Text>
          </Flex>
          {true && ( // TODO: Added chat box expanding
            <div style={{ paddingRight: 5 }}>
              <ActionIcon
                color="gray.0"
                size="lg"
                variant="transparent"
                onClick={props.minimizedSendBox}
              >
                <IconChevronDown size="1rem" />
              </ActionIcon>
            </div>
          )}
        </Group>
      </div>
      <div
        style={{
          flexBasis: "85%",
          position: "relative",
          paddingLeft: 10,
          paddingRight: 10,
        }}
      >
        <Flex justify={"space-between"} mt={10} gap={"xs"}>
          <Flex align={"center"} gap={"xs"} w="35%">
            <Text fw={700} fz={"10px"} color="gray.6" w="35%">
              Reply Label
            </Text>
            <Select
              w="65%"
              size="xs"
              onChange={(val) => {
                setReplyLabel(val || "");
                setBumpFramework(
                  bumpFrameworks.find((bf) => bf.substatus === val) ||
                    bumpFrameworks[0]
                );

                updateChannelStatus(
                  openedProspectId,
                  userToken,
                  "LINKEDIN",
                  val || "",
                  false,
                  true
                ).then((res) => {
                  showNotification({
                    id: "update-channel-status",
                    title: "Status updated",
                    message: "",
                    color: "green",
                    autoClose: 3000,
                  });

                  queryClient.refetchQueries({
                    queryKey: [
                      `query-get-dashboard-prospect-${openedProspectId}`,
                    ],
                  });
                });
              }}
              value={replyLabel}
              withinPortal
              data={replyLabels
                .filter((label) => label)
                .map((label) => ({
                  value: label,
                  label:
                    labelEmoji(label) +
                    " " +
                    convertToTitleCase(
                      label
                        ?.replaceAll("ACTIVE_CONVO_", "")
                        .replaceAll("_", " ")
                        .toLowerCase()
                    ),
                }))}
            />
          </Flex>
          <Flex gap={"xs"} align={"center"} w="70%">
            {/* only show for linkedin */}
            <Text fw={700} fz={"10px"} color="gray.6" w="25%">
              AI Response
            </Text>
            <Flex align={"center"} pos={"relative"} w="75%">
              <Select
                rightSection={
                  <Tooltip
                    label={
                      selectedBumpFramework
                        ? `Manage '${selectedBumpFramework.title}'`
                        : `Configure Msg Gen`
                    }
                    withArrow
                    disabled={openedOutboundChannel != "LINKEDIN"}
                  >
                    <Button
                      variant="outline"
                      color="gray.8"
                      size="xs"
                      w={"100%"}
                      radius={0}
                      sx={(theme) => ({
                        border: "none",
                        borderLeft: `1px solid ${theme.colors.gray[4]}`,
                        paddingLeft: 4,
                        paddingRight: 4,
                      })}
                      onClick={() => {
                        setOpenBumpFrameworks(true);
                      }}
                      disabled={openedOutboundChannel != "LINKEDIN"}
                    >
                      {selectedBumpFramework ? (
                        <IconSettingsFilled size="0.8rem" />
                      ) : (
                        <IconSettings size="0.8rem" />
                      )}
                    </Button>
                  </Tooltip>
                }
                withinPortal
                placeholder={
                  filteredFrameworkData.length > 0
                    ? "Select Framework"
                    : "No Frameworks"
                }
                size="xs"
                disabled={filteredFrameworkData.length === 0}
                defaultValue={
                  filteredFrameworkData.length > 0
                    ? filteredFrameworkData[0] + ""
                    : undefined
                }
                data={filteredFrameworkData}
                // styles={{
                //   input: {
                //     borderColor: "black",
                //     borderRight: "0",
                //     borderLeft: "0",
                //   },
                //   dropdown: { minWidth: 250 },
                // }}
                onChange={(value) => {
                  if (openedOutboundChannel === "LINKEDIN") {
                    const selected = bumpFrameworks.find(
                      (bf) => bf.id === parseInt(value as string)
                    );
                    if (selected) {
                      setBumpFramework(selected);
                      if (selected.substatus) {
                        setReplyLabel(selected.substatus);
                      }
                    }

                    const substatus =
                      bumpFrameworks.length > 0
                        ? bumpFrameworks[0].substatus
                        : undefined;
                    setSetOpenBumpFrameworksSubstatus(substatus);
                  } else if (
                    openedOutboundChannel === "EMAIL" ||
                    openedOutboundChannel === "SMARTLEAD"
                  ) {
                    const selected = emailReplyFrameworks.find(
                      (step) => step.id === parseInt(value as string)
                    );
                    console.log("email selected", selected);
                    if (selected) {
                      setEmailReplyFramework(selected);
                    }
                  }
                }}
                value={
                  openedOutboundChannel === "LINKEDIN"
                    ? selectedBumpFramework?.id + ""
                    : selectedEmailReplyFramework?.id + ""
                }
              />
            </Flex>

            <Button
              leftIcon={<IconPencil size="1rem" />}
              variant="outline"
              color="gray.6"
              sx={{
                "&[data-disabled]": {
                  backgroundColor: "white",
                  border: "1px solid black",
                  pointerEvents: "all",
                },
              }}
              size="xs"
              disabled={
                (openedOutboundChannel === "LINKEDIN" &&
                  (bumpFrameworks === undefined ||
                    bumpFrameworks?.length === 0)) ||
                (openedOutboundChannel != "LINKEDIN" &&
                  (emailReplyFrameworks === undefined ||
                    emailReplyFrameworks?.length === 0))
              }
              onClick={async () => {
                setMsgLoading(true);
                if (openedOutboundChannel === "LINKEDIN") {
                  const result = await generateAIFollowup(
                    userToken,
                    props.prospectId,
                    selectedBumpFramework
                  );
                  setMessageDraft(result.msg);
                  setAiMessage(result.msg);
                  setAiGenerated(result.aiGenerated);
                } else if (openedOutboundChannel === "EMAIL") {
                  if (!currentConvoEmailThread) {
                    showNotification({
                      id: "send-email-message-error",
                      title: "Error",
                      message: "Please select an email thread",
                      color: "red",
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }
                  if (!selectedEmailReplyFramework) {
                    showNotification({
                      id: "send-email-message-error",
                      title: "Error",
                      message: "Please select an email reply framework",
                      color: "red",
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }

                  const result = await postGenerateEmailReplyUsingFramework(
                    userToken,
                    selectedEmailReplyFramework?.id,
                    props.prospectId
                  );

                  // Clean the result
                  const email_body = result.data.message;
                  if (!email_body) {
                    showNotification({
                      id: "generate-email-message-error",
                      title: "Error",
                      message: "Failed to generate message. Please try again.",
                      color: "red",
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }
                  const message = email_body;
                  messageDraftEmail.current = message;
                  setMessageDraft(message);
                  setAiMessage(message);
                  setAiGenerated(true);
                }
                setMsgLoading(false);
              }}
            >
              Generate {openedOutboundChannel === "LINKEDIN" ? "" : "Email"}
            </Button>
          </Flex>
        </Flex>

        <Box pos={"relative"}>
          {openedOutboundChannel === "LINKEDIN" ? (
            <Textarea
              minRows={5}
              maxRows={8}
              mt="xs"
              color="gray"
              placeholder="Your message..."
              value={messageDraft}
              onChange={(event) => _setMessageDraft(event.currentTarget.value)}
              onKeyDown={getHotkeyHandler([
                [
                  "mod+Enter",
                  () => {
                    sendMessage();
                  },
                ],
              ])}
            />
          ) : (
            <Box mt="xs">
              <RichTextArea
                onChange={(value, rawValue) => {
                  messageDraftRichRaw.current = rawValue;
                  messageDraftEmail.current = value;
                }}
                value={messageDraftRichRaw.current}
                height={110}
              />
            </Box>
          )}

          {aiGenerated && (
            <AutoBumpFrameworkInfo
              useBumpFramework={selectedBumpFramework !== undefined}
              bump_title={selectedBumpFramework?.title || "None"}
              bump_description={
                selectedBumpFramework?.description || "No framework"
              }
              bump_length={selectedBumpFramework?.bump_length || "No length"}
              account_research_points={
                selectedBumpFramework?.account_research || []
              }
              bump_number_sent={selectedBumpFramework?.etl_num_times_used}
              bump_number_converted={
                selectedBumpFramework?.etl_num_times_converted
              }
            />
          )}
        </Box>

        <Flex
          align="center"
          direction="row"
          justify={"space-between"}
          wrap="wrap"
        >
          <Flex mt="xs" align="center">
            {openedOutboundChannel === "LINKEDIN" && (
              <Tooltip
                withArrow
                position="bottom"
                label="Smart Generate with AI"
              >
                <Button
                  leftIcon={<IconWand size="0.8rem" />}
                  color="grape"
                  size="xs"
                  sx={{ borderRadius: "4px 0px 0px 4px" }}
                  onClick={() => {
                    showNotification({
                      id: "generate-linkedin-message",
                      title: "Generating message ...",
                      message: "",
                      color: "blue",
                      autoClose: 3000,
                    });
                    smartGenerate("");
                  }}
                >
                  Smart Generate
                </Button>
              </Tooltip>
            )}
            <Tooltip
              label="Co-pilot a response by providing feedback"
              withArrow
              position="bottom"
            >
              <Button
                variant="outline"
                color="grape"
                size="xs"
                sx={{
                  width: "auto",
                  borderLeft: "none",
                  borderRadius: "0px 4px 4px 0px",
                }}
                onClick={() => {
                  let tempInputValue = "";
                  openConfirmModal({
                    title: "Co-pilot a response",
                    children: (
                      <Textarea
                        description="Give feedback on how to respond and a draft will be created"
                        placeholder="Describe how you want to form the generated text"
                        onChange={(event) => {
                          tempInputValue = event.currentTarget.value;
                        }}
                      />
                    ),
                    labels: {
                      confirm: "Generate with feedback",
                      cancel: "Cancel",
                    },
                    onCancel: () => {},
                    onConfirm: () => {
                      showNotification({
                        id: "generate-linkedin-message",
                        title: "Generating message ...",
                        message: "",
                        color: "blue",
                        autoClose: 3000,
                      });
                      smartGenerate(tempInputValue);
                    },
                  });
                }}
              >
                <IconMessageDots size="1rem" />
              </Button>
            </Tooltip>
          </Flex>

          <Flex mt="xs" align="center" direction="row" justify={"end"}>
            <Popover
              position="bottom"
              withArrow
              shadow="md"
              trapFocus
              opened={showCalendarPopup}
            >
              <Popover.Target>
                <Tooltip label="Set a custom snooze day" withArrow withinPortal>
                  <Flex>
                    <Button
                      onClick={() => setShowCalendarPopup((v) => !v)}
                      size="xs"
                      sx={{
                        borderTopRightRadius: 0,
                        borderBottomRightRadius: 0,
                      }}
                    >
                      <IconZzz size={"1rem"} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>
              <Popover.Dropdown>
                <Calendar
                  placeholder={"Select a date"}
                  minDate={moment(new Date()).add(1, "days").toDate()}
                  getDayProps={(date) => ({
                    selected: moment(snoozeDay).isSame(date, "day"),
                    onClick: () => {
                      setShowCalendarPopup(false);
                      setSnoozeDay(date);
                    },
                  })}
                />
              </Popover.Dropdown>
            </Popover>

            <Button
              size="xs"
              sx={{
                borderTopRightRadius: 0,
                borderBottomRightRadius: 0,
                borderTopLeftRadius: 0,
                borderBottomLeftRadius: 0,
                borderLeft: `1px solid #fff`,
                borderRight: `1px solid #fff`,
              }}
              onClick={() => sendMessage()}
              styles={(theme) => ({
                rightIcon: {
                  borderLeft: `1px solid ${theme.white}`,
                  marginLeft: "0.5rem",
                  paddingLeft: "0.25rem",
                },
              })}
            >
              {scheduleDay
                ? "Schedule for [" +
                  moment(scheduleDay).format("MMM Do h:mmA") +
                  "] "
                : "Send"}{" "}
              and Snooze for {moment(snoozeDay).diff(new Date(), "days") + 1}{" "}
              days
            </Button>
            <Popover
              position="bottom"
              withArrow
              shadow="md"
              trapFocus
              opened={showSchedulePopup}
            >
              <Popover.Target>
                <Tooltip
                  label="Schedule a send time into the future"
                  withArrow
                  withinPortal
                >
                  <Flex>
                    <Button
                      onClick={() => setShowSchedulePopup((v) => !v)}
                      size="xs"
                      sx={{ borderTopLeftRadius: 0, borderBottomLeftRadius: 0 }}
                    >
                      <IconClock24 size={"1rem"} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>

              <Popover.Dropdown>
                <Calendar
                  placeholder={"Select a date"}
                  minDate={moment(new Date()).add(1, "days").toDate()}
                  getDayProps={(date) => ({
                    selected: moment(scheduleDay).isSame(date, "day"),
                    onClick: () => {
                      // Preserve the time
                      const hour = moment(scheduleDay).hour();
                      const minute = moment(scheduleDay).minute();
                      const newDate = moment(date)
                        .set("hour", hour)
                        .set("minute", minute)
                        .toDate();
                      setScheduleDay(newDate);
                    },
                  })}
                />
                <Flex
                  mt="xs"
                  direction="row"
                  justify={"space-between"}
                  align="flex-end"
                >
                  <TimeInput
                    w="100%"
                    label="Custom Time"
                    size="sm"
                    value={moment(scheduleDay).format("HH:mm")}
                    onChange={(event) => {
                      const value = event.currentTarget.value; // Format is HH:MM
                      const hour = parseInt(value.split(":")[0]);
                      const minute = parseInt(value.split(":")[1]);
                      const newDate = moment(scheduleDay)
                        .set("hour", hour)
                        .set("minute", minute)
                        .toDate();
                      setScheduleDay(newDate);
                    }}
                  />
                  <Tooltip label="Schedule for now" withArrow withinPortal>
                    <Flex>
                      <Button
                        size="xs"
                        mb="xs"
                        ml="sm"
                        variant="transparent"
                        color="red"
                        onClick={() => {
                          setShowSchedulePopup(false);
                          setScheduleDay(undefined);
                        }}
                      >
                        <IconX size="1rem" />
                      </Button>
                    </Flex>
                  </Tooltip>
                </Flex>
              </Popover.Dropdown>
            </Popover>
          </Flex>
        </Flex>
      </div>
    </Paper>
  );
});
