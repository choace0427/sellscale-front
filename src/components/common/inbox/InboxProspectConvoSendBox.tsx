import moment from 'moment';
import {
  openedProspectIdState,
  openedBumpFameworksState,
  selectedBumpFrameworkState,
  currentConvoLiMessageState,
  currentConvoChannelState,
  currentConvoEmailMessageState,
  fetchingProspectIdState,
  tempHiddenProspectsState,
  selectedEmailSequenceStepState,
  selectedEmailThread,
  bumpFrameworkSelectedSubstatusState,
  selectedEmailReplyFrameworkState,
} from '@atoms/inboxAtoms';
import { userDataState, userTokenState } from '@atoms/userAtoms';
import { openConfirmModal } from '@mantine/modals';
import {
  Paper,
  Flex,
  Textarea,
  Text,
  Button,
  useMantineTheme,
  Group,
  ActionIcon,
  LoadingOverlay,
  Tooltip,
  Select,
  Box,
  Popover,
  Indicator,
  MultiSelect,
} from '@mantine/core';
import { getHotkeyHandler } from '@mantine/hooks';
import { hideNotification, showNotification } from '@mantine/notifications';
import {
  IconExternalLink,
  IconWriting,
  IconSend,
  IconChevronUp,
  IconChevronDown,
  IconSettings,
  IconArrowsDiagonalMinimize2,
  IconClock,
  IconArrowUp,
  IconCalendar,
  IconZzz,
  IconHourglass,
  IconX,
  IconPencil,
  IconTags,
} from '@tabler/icons';
import {
  IconClock24,
  IconMessage2Cog,
  IconSettingsFilled,
  IconWand,
  IconMessageDots,
} from '@tabler/icons-react';
import { useQueryClient } from '@tanstack/react-query';
import { deleteAutoBumpMessage } from '@utils/requests/autoBumpMessage';
import { sendLinkedInMessage } from '@utils/requests/sendMessage';
import _, { debounce, get, set } from 'lodash';
import {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from 'react';
import { useRecoilState, useRecoilValue } from 'recoil';
import {
  BumpFramework,
  EmailReplyFramework,
  EmailSequenceStep,
  EmailThread,
  LinkedInMessage,
  Prospect,
} from 'src';
import { generateAIEmailReply, generateAIFollowup } from './InboxProspectConvoBumpFramework';
import AutoBumpFrameworkInfo from '@common/prospectDetails/AutoBumpFrameworkInfo';
import { ratio as fuzzratio } from 'fuzzball';
import { sendEmail } from '@utils/requests/sendEmail';
import RichTextArea from '@common/library/RichTextArea';
import TextAreaWithAI from '@common/library/TextAreaWithAI';
import { JSONContent } from '@tiptap/react';
import DOMPurify from 'dompurify';
import { postGenerateFollowupEmail } from '@utils/requests/emailMessageGeneration';
import { API_URL } from '@constants/data';
import { Calendar, DateTimePicker, TimeInput } from '@mantine/dates';
import { updateChannelStatus } from '@common/prospectDetails/ProspectDetailsChangeStatus';
import postSmartleadReply from '@utils/requests/postSmartleadReply';
import { convertToTitleCase } from '@utils/stringFormatting';
import { postGenerateEmailReplyUsingFramework } from '@utils/requests/emailReplies';
import { getBumpFrameworks } from '@utils/requests/getBumpFrameworks';

export default forwardRef(function InboxProspectConvoSendBox(
  props: {
    prospectId: number;
    linkedin_public_id: string;
    email: string;
    nylasMessageId?: string;
    scrollToBottom?: () => void;
    msgLoading?: boolean;
    minimizedSendBox: () => void;
    currentSubstatus?: string;
    triggerGetSmartleadProspectConvo?: () => void;
    archetypeId?: number;
  },
  ref
) {
  useImperativeHandle(
    ref,
    () => {
      return {
        getAiGenerated: () => aiGenerated,
        setAiGenerated: setAiGenerated,
        getMessageDraft: () => messageDraft,
        setMessageDraft: (
          msg: string,
          bumpFramework?: {
            description?: string;
            id?: number;
            length?: string;
            title?: string;
          },
          accountResearch?: string[]
        ) => {
          // bumpFramework is no longer used because we want to show default bump framework and NOT the autogenerated one
          setMessageDraft(msg);
          if (accountResearch) {
            setBumpFramework((prev) => {
              if (!prev) {
                return prev;
              }
              return {
                ...prev,
                account_research: accountResearch,
              };
            });
          }
        },
        setAiMessage: (msg: string) => {
          setAiMessage(msg);
        },
        setBumpFrameworks: (bumpFrameworks: BumpFramework[]) => {
          setBumpFrameworks(bumpFrameworks);

          // Set the default bump framework
          // if (!selectedBumpFramework?.id) {
          //   if (bumpFrameworks.length > 0) {
          //     setBumpFramework(bumpFrameworks[0]);
          //     for (let i = 0; i < bumpFrameworks.length; i++) {
          //       if (bumpFrameworks[i].default) {
          //         setBumpFramework(bumpFrameworks[i]);
          //         break;
          //       }
          //     }
          //   }
          // }
        },
        setEmailReplyFrameworks: (emailReplyFrameworks: EmailReplyFramework[]) => {
          // Only set the sequence step to the selected substatus
          setEmailReplyFrameworks(emailReplyFrameworks);
          // Set the default bump framework
          // if (emailReplyFrameworks.length > 0) {
          //   setEmailSequenceStep(emailReplyFrameworks[0]);
          //   for (let i = 0; i < emailReplyFrameworks.length; i++) {
          //     if (emailReplyFrameworks[i].default) {
          //       setEmailSequenceStep(emailReplyFrameworks[i]);
          //       break;
          //     }
          //   }
          // }
        },
      };
    },
    []
  );

  const theme = useMantineTheme();
  const queryClient = useQueryClient();
  const userToken = useRecoilValue(userTokenState);
  const userData = useRecoilValue(userDataState);
  const [scheduleDay, setScheduleDay] = useState<Date | undefined>(undefined);
  const [showSchedulePopup, setShowSchedulePopup] = useState(false);
  const [snoozeDay, setSnoozeDay] = useState(moment(new Date()).add(4, 'days').toDate());
  const openedProspectId = useRecoilValue(openedProspectIdState);
  const openedOutboundChannel = useRecoilValue(currentConvoChannelState);
  const [fetchingProspectId, setFetchingProspectId] = useRecoilState(fetchingProspectIdState);
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [openBumpFrameworks, setOpenBumpFrameworks] = useRecoilState(openedBumpFameworksState);
  const [setOpenBumpFrameworksSubstatus, setSetOpenBumpFrameworksSubstatus] = useRecoilState(
    bumpFrameworkSelectedSubstatusState
  );
  const [selectedBumpFramework, setBumpFramework] = useRecoilState(selectedBumpFrameworkState); // LinkedIn
  const [selectedEmailReplyFramework, setEmailReplyFramework] = useRecoilState(
    selectedEmailReplyFrameworkState
  ); // Email
  const [currentConvoLiMessages, setCurrentConvoLiMessages] = useRecoilState(
    currentConvoLiMessageState
  );
  const [currentConvoEmailMessages, setCurrentConvoEmailMessages] = useRecoilState(
    currentConvoEmailMessageState
  );
  const [currentConvoEmailThread, setCurrentConvoEmailThread] = useRecoilState(selectedEmailThread);

  const [tempHiddenProspects, setTempHiddenProspects] = useRecoilState(tempHiddenProspectsState);

  const [bumpFrameworks, setBumpFrameworks] = useState<BumpFramework[]>([]);
  const [emailReplyFrameworks, setEmailReplyFrameworks] = useState<EmailReplyFramework[]>([]);
  const [replyLabel, setReplyLabel] = useState(props.currentSubstatus);
  // We use this to store the value of the text area
  const [messageDraft, _setMessageDraft] = useState('');
  // We use this to store the raw value of the rich text editor
  const messageDraftRichRaw = useRef<JSONContent | string>();

  // We use this to set the value of the text area (for both rich text and normal text)
  const setMessageDraft = (value: string) => {
    messageDraftRichRaw.current = value;
    _setMessageDraft(value);
  };
  // For email we have to use this ref instead, otherwise the textbox does a weird refocusing.
  const messageDraftEmail = useRef('');

  const [aiMessage, setAiMessage] = useState('');
  const [aiGenerated, setAiGenerated] = useState(false);
  const [msgLoading, setMsgLoading] = useState(props.msgLoading || false);

  const [ccEmails, setCcEmails] = useState<string[]>([]);

  const sendMessage = async () => {
    setMsgLoading(true);

    // Delete the auto bump message if it exists
    await deleteAutoBumpMessage(userToken, props.prospectId);

    // Hack to update the prospect list to temp show they're in purgatory
    setTempHiddenProspects(tempHiddenProspects.concat([props.prospectId]));

    if (openedOutboundChannel === 'LINKEDIN') {
      const msg = messageDraft;
      setMessageDraft('');
      showNotification({
        id: 'send-linkedin-message',
        title: scheduleDay ? 'Scheduling message...' : 'Sending message ...',
        message: '',
        color: 'green',
        autoClose: 3000,
      });
      setTimeout(() => setFetchingProspectId(-1), 15000);

      setFetchingProspectId(openedProspectId);
      sendLinkedInMessage(
        userToken,
        props.prospectId,
        msg,
        aiGenerated,
        undefined,
        selectedBumpFramework?.id,
        selectedBumpFramework?.title,
        selectedBumpFramework?.description,
        selectedBumpFramework?.bump_length,
        selectedBumpFramework?.account_research,
        snoozeDay,
        scheduleDay
      ).then(() => {
        queryClient.refetchQueries({
          queryKey: [
            `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
          ],
        });
      });
      if (true) {
        let yourMessage = _.cloneDeep(currentConvoLiMessages || [])
          .reverse()
          .find((msg) => msg.connection_degree === 'You');
        if (yourMessage) {
          yourMessage.message = msg;
          yourMessage.date = new Date().toUTCString();
          yourMessage.ai_generated = false;
          setCurrentConvoLiMessages([...(currentConvoLiMessages || []), yourMessage]);
        } else {
          queryClient.refetchQueries({
            queryKey: [
              `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
            ],
          });
          queryClient.refetchQueries({
            queryKey: ['query-prospects-list'],
          });
        }
        showNotification({
          id: 'send-linkedin-message',
          title: scheduleDay ? 'Message Scheduled' : 'Message Sent',
          message: '',
          color: 'green',
        });
      } else {
        showNotification({
          id: 'send-linkedin-message-error',
          title: 'Error',
          message: 'Failed to send message. Please try again later.',
          color: 'red',
          autoClose: false,
        });
      }
    } else if (openedOutboundChannel === 'SMARTLEAD') {
      const prospectid = props.prospectId;
      const response = await postSmartleadReply(
        userToken,
        prospectid,
        messageDraftEmail.current,
        scheduleDay,
        ccEmails
      );
      if (response.status !== 'success') {
        showNotification({
          title: 'Error',
          message: 'Failed to send email',
          color: 'red',
        });
      } else {
        if (scheduleDay) {
          showNotification({
            title: 'Success',
            message: 'Email scheduled to send.',
            color: 'green',
          });
        } else {
          showNotification({
            title: 'Success',
            message: 'Email sent. It may take a few minutes to appear in your inbox.',
            color: 'green',
          });
        }

        setMessageDraft('');
      }
      if (props?.triggerGetSmartleadProspectConvo) {
        props?.triggerGetSmartleadProspectConvo();
      }
      setScheduleDay(undefined);
    } else {
      if (currentConvoEmailMessages === undefined || currentConvoEmailMessages.length === 0) {
        showNotification({
          id: 'send-email-message-error',
          title: 'Error',
          message: 'Please select an email thread',
          color: 'red',
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }
      const msg = messageDraftEmail.current;
      if (msg.length === 0) {
        showNotification({
          id: 'send-email-message-error',
          title: 'Error',
          message: 'Please enter a message',
          color: 'red',
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }

      // Get the last message
      const replyToMessageID =
        currentConvoEmailMessages[currentConvoEmailMessages.length - 1].nylas_message_id;
      const result = await sendEmail(
        userToken,
        props.prospectId,
        `Re: ${currentConvoEmailThread?.subject}`,
        msg,
        aiGenerated,
        replyToMessageID
      );
      if (result.status === 'success') {
        let yourMessage = _.cloneDeep(currentConvoEmailMessages || [])
          .reverse()
          .find((msg) => msg.from_sdr);
        if (yourMessage) {
          yourMessage.body = msg;
          yourMessage.date_received = new Date().toUTCString();
          yourMessage.ai_generated = false;
          setCurrentConvoEmailMessages([...(currentConvoEmailMessages || []), yourMessage]);
        } else {
          queryClient.refetchQueries({
            queryKey: [
              `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
            ],
          });
        }
        messageDraftEmail.current = '';
        messageDraftRichRaw.current = '';
        setMessageDraft('');
      } else {
        showNotification({
          id: 'send-email-message-error',
          title: 'Error',
          message: 'Failed to send message. Please try again later.',
          color: 'red',
          autoClose: false,
        });
      }
    }

    setMsgLoading(false);
    setAiGenerated(false);
    setTimeout(() => props.scrollToBottom && props.scrollToBottom(), 100);
  };

  // If messageDraft is cleared, odds are that the AI generated message was cleared, and the new message is likely not to be AI generated
  useEffect(() => {
    checkFuzz(messageDraft, aiMessage);
  }, [messageDraft, aiMessage]);

  const checkFuzz = useCallback(
    debounce((message, aiMessage) => {
      const ratio = fuzzratio(message, aiMessage);
      // ratio > 5 && setAiGenerated(true);
      // ratio <= 5 && setAiGenerated(false);
      setAiGenerated(true);
    }, 200),
    []
  );

  useEffect(() => {
    (async () => {
      const result = await getBumpFrameworks(
        userToken,
        ['ACTIVE_CONVO'],
        [],
        [],
        undefined,
        undefined,
        undefined,
        undefined,
        props.archetypeId
      );

      let bumpFrameworkArray = [] as BumpFramework[];
      for (const bumpFramework of result.data.bump_frameworks as BumpFramework[]) {
        if (bumpFramework.default) {
          bumpFrameworkArray.unshift(bumpFramework);
        } else {
          bumpFrameworkArray.push(bumpFramework);
        }
      }

      setBumpFrameworks(bumpFrameworkArray);
      setBumpFramework(bumpFrameworkArray.length > 0 ? bumpFrameworkArray[0] : undefined);
    })();
  }, [props.prospectId, props.archetypeId, replyLabel]);

  const smartGenerate = async (additional_instructions: string) => {
    setMsgLoading(true);
    if (openedOutboundChannel === 'LINKEDIN') {
      const result = fetch(`${API_URL}/li_conversation/prospect/generate_smart_response`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${userToken}`,
        },
        body: JSON.stringify({
          prospect_id: props.prospectId,
          additional_instructions: additional_instructions,
        }),
      })
        .then((res) => res.json())
        .then((j) => {
          const message = j['message'];

          setMessageDraft(message);
          setAiMessage(message);
          setBumpFramework(j['bump_framework']);
          setAiGenerated(true);

          showNotification({
            id: 'generate-linkedin-message',
            title: 'Generated message',
            message: '',
            color: 'green',
            autoClose: 3000,
          });
        })
        .catch((e) => {
          showNotification({
            id: 'generate-linkedin-message-error',
            title: 'Error',
            message: 'Failed to generate message',
            color: 'red',
            autoClose: 3000,
          });
        })
        .finally(() => {
          setMsgLoading(false);
        });
    }
  };

  useEffect(() => {
    if (replyLabel !== props.currentSubstatus) {
      setReplyLabel(props.currentSubstatus);
    }
  }, [props.currentSubstatus]);

  const replyLabels = useMemo(() => {
    const labels = [
      'ACTIVE_CONVO_QUESTION',
      'ACTIVE_CONVO_QUAL_NEEDED',
      'ACTIVE_CONVO_OBJECTION',
      'ACTIVE_CONVO_SCHEDULING',
      'ACTIVE_CONVO_NEXT_STEPS',
      'ACTIVE_CONVO_REVIVAL',
      'ACTIVE_CONVO_CIRCLE_BACK',
      'ACTIVE_CONVO_REFERRAL',
      'ACTIVE_CONVO_QUEUED_FOR_SNOOZE',
      'ACTIVE_CONVO_CONTINUE_SEQUENCE',
    ];

    return Array.from(labels);
  }, [bumpFrameworks]);

  const labelEmoji = (label: string) => {
    switch (label) {
      case 'ACTIVE_CONVO_QUESTION':
        return '‚ùì';
      case 'ACTIVE_CONVO_QUAL_NEEDED':
        return 'üëç';
      case 'ACTIVE_CONVO_OBJECTION':
        return 'üëÜ';
      case 'ACTIVE_CONVO_SCHEDULING':
        return 'üìÜ';
      case 'ACTIVE_CONVO_NEXT_STEPS':
        return '‚û°Ô∏è';
      case 'ACTIVE_CONVO_REVIVAL':
        return 'üè•';
      case 'ACTIVE_CONVO_CIRCLE_BACK':
        return 'üîÑ';
      case 'ACTIVE_CONVO_REFERRAL':
        return 'üë•';
      case 'ACTIVE_CONVO_QUEUED_FOR_SNOOZE':
        return 'üí§';
      case 'ACTIVE_CONVO_CONTINUE_SEQUENCE':
        return '';
      default:
        return '';
    }
  };

  const filteredFrameworkData =
    openedOutboundChannel === 'LINKEDIN'
      ? bumpFrameworks.length > 0
        ? bumpFrameworks
            .sort((a: BumpFramework, b: BumpFramework) => {
              return a.title.localeCompare(b.title);
            })
            .filter((i) => {
              if (!replyLabel && replyLabel !== 'ACTIVE_CONVO_CONTINUE_SEQUENCE') {
                return i;
              }

              if (replyLabel === 'ACTIVE_CONVO_CONTINUE_SEQUENCE') {
                return i.overall_status === 'ACCEPTED' || i.overall_status === 'BUMPED';
              }

              return i.substatus === replyLabel;
            })
            .map((bf: BumpFramework) => {
              let title = bf.title;
              if (bf.overall_status === 'ACCEPTED' || bf.overall_status === 'BUMPED') {
                title = '(step #' + (bf.bumped_count ? bf.bumped_count + 1 : 1) + ') ' + bf.title;
              }

              return {
                value: bf.id + '',
                label: title,
              };
            })
        : []
      : emailReplyFrameworks?.length > 0
      ? emailReplyFrameworks
          .sort((a: EmailReplyFramework, b: EmailReplyFramework) => {
            return a.title.localeCompare(b.title);
          })
          .filter((i) => {
            if (!replyLabel) {
              return i;
            }
            return i.substatus === replyLabel;
          })
          .map((step: EmailReplyFramework) => {
            return {
              value: step.id + '',
              // label: (step.default ? "üü¢ " : "‚ö™Ô∏è ") + step.title,
              label: step.title,
            };
          })
      : [];

  return (
    <Paper
      shadow='sm'
      withBorder
      radius={theme.radius.md}
      sx={{
        display: 'flex',
        flexDirection: 'column',
        flexWrap: 'nowrap',
        position: 'relative',
      }}
      pb={8}
      mah={500}
    >
      <LoadingOverlay visible={msgLoading} />
      <div
        style={{
          flexBasis: '15%',
          backgroundColor: '#25262b',
          borderTopLeftRadius: theme.radius.md,
          borderTopRightRadius: theme.radius.md,
        }}
      >
        <Group spacing={0} position='apart'>
          <Flex wrap='nowrap' align='center'>
            <Text color='white' fz={14} fw={500} pl={15} pt={5}>
              {openedOutboundChannel === 'LINKEDIN' ? 'Message via LinkedIn' : 'Reply via Email'}
            </Text>
            <Text
              pl={10}
              pt={5}
              size='xs'
              fs='italic'
              color='gray.3'
              component='a'
              target='_blank'
              rel='noopener noreferrer'
              href={
                openedOutboundChannel === 'LINKEDIN'
                  ? `https://www.linkedin.com/in/${props.linkedin_public_id}`
                  : `mailto:${props.email}`
              }
            >
              {openedOutboundChannel === 'LINKEDIN'
                ? `linkedin.com/in/${_.truncate(props.linkedin_public_id, {
                    length: 20,
                  })}`
                : props.email}{' '}
              <IconExternalLink size='0.65rem' />
            </Text>
          </Flex>
          {true && ( // TODO: Added chat box expanding
            <div style={{ paddingRight: 5 }}>
              <ActionIcon
                color='gray.0'
                size='lg'
                variant='transparent'
                onClick={props.minimizedSendBox}
              >
                <IconChevronDown size='1rem' />
              </ActionIcon>
            </div>
          )}
        </Group>
      </div>
      <div
        style={{
          flexBasis: '85%',
          position: 'relative',
          paddingLeft: 10,
          paddingRight: 10,
        }}
      >
        <Flex justify={'space-between'} mt={10} gap={'xs'}>
          <Flex align={'center'} gap={'xs'} w='35%'>
            <Text fw={700} fz={'10px'} color='gray.6' w='35%'>
              Reply Label
            </Text>
            <Select
              w='65%'
              size='xs'
              onChange={(val) => {
                setReplyLabel(val || '');
                setBumpFramework(
                  bumpFrameworks.find((bf) => bf.substatus === val) || bumpFrameworks[0]
                );

                updateChannelStatus(
                  openedProspectId,
                  userToken,
                  'LINKEDIN',
                  val || '',
                  false,
                  true
                ).then((res) => {
                  showNotification({
                    id: 'update-channel-status',
                    title: 'Status updated',
                    message: '',
                    color: 'green',
                    autoClose: 3000,
                  });

                  queryClient.refetchQueries({
                    queryKey: [`query-get-dashboard-prospect-${openedProspectId}`],
                  });
                });
              }}
              value={replyLabel}
              withinPortal
              data={replyLabels
                .filter((label) => label)
                .map((label) => ({
                  value: label,
                  label:
                    labelEmoji(label) +
                    ' ' +
                    convertToTitleCase(
                      label?.replaceAll('ACTIVE_CONVO_', '').replaceAll('_', ' ').toLowerCase()
                    ),
                }))}
            />
          </Flex>
          <Flex gap={'xs'} align={'center'} w='70%'>
            {/* only show for linkedin */}
            <Text fw={700} fz={'10px'} color='gray.6' w='25%'>
              AI Response
            </Text>
            <Flex align={'center'} pos={'relative'} w='75%'>
              <Select
                rightSection={
                  <Tooltip
                    label={
                      selectedBumpFramework
                        ? `Manage '${selectedBumpFramework.title}'`
                        : `Configure Msg Gen`
                    }
                    withArrow
                    disabled={openedOutboundChannel != 'LINKEDIN'}
                  >
                    <Button
                      variant='outline'
                      color='gray.8'
                      size='xs'
                      w={'100%'}
                      radius={0}
                      sx={(theme) => ({
                        border: 'none',
                        borderLeft: `1px solid ${theme.colors.gray[4]}`,
                        paddingLeft: 4,
                        paddingRight: 4,
                      })}
                      onClick={() => {
                        setOpenBumpFrameworks(true);
                      }}
                      disabled={openedOutboundChannel != 'LINKEDIN'}
                    >
                      {selectedBumpFramework ? (
                        <IconSettingsFilled size='0.8rem' />
                      ) : (
                        <IconSettings size='0.8rem' />
                      )}
                    </Button>
                  </Tooltip>
                }
                withinPortal
                placeholder={
                  filteredFrameworkData.length > 0 ? 'Select Framework' : 'No Frameworks'
                }
                size='xs'
                disabled={filteredFrameworkData.length === 0}
                defaultValue={
                  filteredFrameworkData.length > 0 ? filteredFrameworkData[0] + '' : undefined
                }
                data={filteredFrameworkData}
                // styles={{
                //   input: {
                //     borderColor: "black",
                //     borderRight: "0",
                //     borderLeft: "0",
                //   },
                //   dropdown: { minWidth: 250 },
                // }}
                onChange={(value) => {
                  if (openedOutboundChannel === 'LINKEDIN') {
                    const selected = bumpFrameworks.find(
                      (bf) => bf.id === parseInt(value as string)
                    );
                    if (selected) {
                      setBumpFramework(selected);
                      if (selected.substatus) {
                        setReplyLabel(selected.substatus);
                      }
                    }

                    const substatus =
                      bumpFrameworks.length > 0 ? bumpFrameworks[0].substatus : undefined;
                    setSetOpenBumpFrameworksSubstatus(substatus);
                  } else if (
                    openedOutboundChannel === 'EMAIL' ||
                    openedOutboundChannel === 'SMARTLEAD'
                  ) {
                    const selected = emailReplyFrameworks.find(
                      (step) => step.id === parseInt(value as string)
                    );
                    console.log('email selected', selected);
                    if (selected) {
                      setEmailReplyFramework(selected);
                    }
                  }
                }}
                value={
                  openedOutboundChannel === 'LINKEDIN'
                    ? selectedBumpFramework?.id + ''
                    : selectedEmailReplyFramework?.id + ''
                }
              />
            </Flex>

            <Button
              leftIcon={<IconPencil size='1rem' />}
              variant='outline'
              color='gray.6'
              sx={{
                '&[data-disabled]': {
                  backgroundColor: 'white',
                  border: '1px solid black',
                  pointerEvents: 'all',
                },
              }}
              size='xs'
              disabled={
                (openedOutboundChannel === 'LINKEDIN' &&
                  (bumpFrameworks === undefined || bumpFrameworks?.length === 0)) ||
                (openedOutboundChannel != 'LINKEDIN' &&
                  (emailReplyFrameworks === undefined || emailReplyFrameworks?.length === 0))
              }
              onClick={async () => {
                setMsgLoading(true);
                if (openedOutboundChannel === 'LINKEDIN') {
                  const result = await generateAIFollowup(
                    userToken,
                    props.prospectId,
                    selectedBumpFramework
                  );
                  setMessageDraft(result.msg);
                  setAiMessage(result.msg);
                  setAiGenerated(result.aiGenerated);
                } else if (
                  openedOutboundChannel === 'EMAIL' ||
                  openedOutboundChannel === 'SMARTLEAD'
                ) {
                  if (!currentConvoEmailThread) {
                    showNotification({
                      id: 'send-email-message-error',
                      title: 'Error',
                      message: 'Please select an email thread',
                      color: 'red',
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }
                  if (!selectedEmailReplyFramework) {
                    showNotification({
                      id: 'send-email-message-error',
                      title: 'Error',
                      message: 'Please select an email reply framework',
                      color: 'red',
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }

                  const result = await postGenerateEmailReplyUsingFramework(
                    userToken,
                    selectedEmailReplyFramework?.id,
                    props.prospectId
                  );

                  // Clean the result
                  const email_body = result.data.message;
                  if (!email_body) {
                    showNotification({
                      id: 'generate-email-message-error',
                      title: 'Error',
                      message: 'Failed to generate message. Please try again.',
                      color: 'red',
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }
                  const message = email_body;
                  messageDraftEmail.current = message;
                  setMessageDraft(message);
                  setAiMessage(message);
                  setAiGenerated(true);
                }
                setMsgLoading(false);
              }}
            >
              Generate {openedOutboundChannel === 'LINKEDIN' ? '' : 'Email'}
            </Button>
          </Flex>
        </Flex>

        <Box pos={'relative'}>
          {openedOutboundChannel === 'LINKEDIN' ? (
            <Textarea
              minRows={5}
              maxRows={8}
              mt='xs'
              color='gray'
              placeholder='Your message...'
              value={messageDraft}
              onChange={(event) => _setMessageDraft(event.currentTarget.value)}
              onKeyDown={getHotkeyHandler([
                [
                  'mod+Enter',
                  () => {
                    sendMessage();
                  },
                ],
              ])}
            />
          ) : (
            <Box mt='xs'>
              <RichTextArea
                onChange={(value, rawValue) => {
                  messageDraftRichRaw.current = rawValue;
                  messageDraftEmail.current = value;
                }}
                value={messageDraftRichRaw.current}
                height={110}
              />
            </Box>
          )}

          {aiGenerated && (
            <AutoBumpFrameworkInfo
              useBumpFramework={selectedBumpFramework !== undefined}
              bump_title={selectedBumpFramework?.title || 'None'}
              bump_description={selectedBumpFramework?.description || 'No framework'}
              bump_length={selectedBumpFramework?.bump_length || 'No length'}
              account_research_points={selectedBumpFramework?.account_research || []}
              bump_number_sent={selectedBumpFramework?.etl_num_times_used}
              bump_number_converted={selectedBumpFramework?.etl_num_times_converted}
            />
          )}
        </Box>

        <Flex align='center' direction='row' justify={'space-between'} wrap='wrap'>
          <Flex mt='xs' align='center'>
            {openedOutboundChannel === 'LINKEDIN' && (
              <Tooltip withArrow position='bottom' label='Smart Generate with AI'>
                <Button
                  leftIcon={<IconWand size='0.8rem' />}
                  color='grape'
                  size='xs'
                  sx={{ borderRadius: '4px 0px 0px 4px' }}
                  onClick={() => {
                    showNotification({
                      id: 'generate-linkedin-message',
                      title: 'Generating message ...',
                      message: '',
                      color: 'blue',
                      autoClose: 3000,
                    });
                    smartGenerate('');
                  }}
                >
                  Smart Generate
                </Button>
              </Tooltip>
            )}
            <Tooltip label='Co-pilot a response by providing feedback' withArrow position='bottom'>
              <Button
                variant='outline'
                color='grape'
                size='xs'
                sx={{
                  width: 'auto',
                  borderLeft: 'none',
                  borderRadius: '0px 4px 4px 0px',
                }}
                onClick={() => {
                  let tempInputValue = '';
                  openConfirmModal({
                    title: 'Co-pilot a response',
                    children: (
                      <Textarea
                        description='Give feedback on how to respond and a draft will be created'
                        placeholder='Describe how you want to form the generated text'
                        onChange={(event) => {
                          tempInputValue = event.currentTarget.value;
                        }}
                      />
                    ),
                    labels: {
                      confirm: 'Generate with feedback',
                      cancel: 'Cancel',
                    },
                    onCancel: () => {},
                    onConfirm: () => {
                      showNotification({
                        id: 'generate-linkedin-message',
                        title: 'Generating message ...',
                        message: '',
                        color: 'blue',
                        autoClose: 3000,
                      });
                      smartGenerate(tempInputValue);
                    },
                  });
                }}
              >
                <IconMessageDots size='1rem' />
              </Button>
            </Tooltip>
          </Flex>

          <Flex mt='xs' align='center' direction='row' justify={'end'}>
            {openedOutboundChannel !== 'LINKEDIN' && (
              <Box px={15}>
                <Popover width={250} position='bottom' withArrow shadow='md'>
                  <Popover.Target>
                    <Indicator
                      inline
                      label={ccEmails.length}
                      size={16}
                      disabled={ccEmails.length == 0}
                    >
                      <ActionIcon variant='filled' color='blue' radius='xl' aria-label='CC Emails'>
                        <IconTags size='1.2rem' stroke={1.5} />
                      </ActionIcon>
                    </Indicator>
                  </Popover.Target>
                  <Popover.Dropdown>
                    <MultiSelect
                      withinPortal
                      data={userData?.meta_data?.handoff_emails ?? []}
                      searchable
                      value={ccEmails}
                      onChange={(value) => {
                        setCcEmails(value);
                      }}
                      placeholder='Add Email to CC'
                    />
                  </Popover.Dropdown>
                </Popover>
              </Box>
            )}

            <Popover position='bottom' withArrow shadow='md' trapFocus opened={showCalendarPopup}>
              <Popover.Target>
                <Tooltip label='Set a custom snooze day' withArrow withinPortal>
                  <Flex>
                    <Button
                      onClick={() => setShowCalendarPopup((v) => !v)}
                      size='xs'
                      sx={{
                        borderTopRightRadius: 0,
                        borderBottomRightRadius: 0,
                      }}
                    >
                      <IconZzz size={'1rem'} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>
              <Popover.Dropdown>
                <Calendar
                  placeholder={'Select a date'}
                  minDate={moment(new Date()).add(1, 'days').toDate()}
                  getDayProps={(date) => ({
                    selected: moment(snoozeDay).isSame(date, 'day'),
                    onClick: () => {
                      setShowCalendarPopup(false);
                      setSnoozeDay(date);
                    },
                  })}
                />
              </Popover.Dropdown>
            </Popover>

            <Button
              size='xs'
              sx={{
                borderTopRightRadius: 0,
                borderBottomRightRadius: 0,
                borderTopLeftRadius: 0,
                borderBottomLeftRadius: 0,
                borderLeft: `1px solid #fff`,
                borderRight: `1px solid #fff`,
              }}
              onClick={() => sendMessage()}
              styles={(theme) => ({
                rightIcon: {
                  borderLeft: `1px solid ${theme.white}`,
                  marginLeft: '0.5rem',
                  paddingLeft: '0.25rem',
                },
              })}
            >
              {scheduleDay
                ? 'Schedule for [' + moment(scheduleDay).format('MMM Do h:mmA') + '] '
                : 'Send'}{' '}
              and Snooze for {moment(snoozeDay).diff(new Date(), 'days') + 1} days
            </Button>
            <Popover position='bottom' withArrow shadow='md' trapFocus opened={showSchedulePopup}>
              <Popover.Target>
                <Tooltip label='Schedule a send time into the future' withArrow withinPortal>
                  <Flex>
                    <Button
                      onClick={() => setShowSchedulePopup((v) => !v)}
                      size='xs'
                      sx={{ borderTopLeftRadius: 0, borderBottomLeftRadius: 0 }}
                    >
                      <IconClock24 size={'1rem'} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>

              <Popover.Dropdown>
                <Calendar
                  placeholder={'Select a date'}
                  minDate={moment(new Date()).add(1, 'days').toDate()}
                  getDayProps={(date) => ({
                    selected: moment(scheduleDay).isSame(date, 'day'),
                    onClick: () => {
                      // Preserve the time
                      const hour = moment(scheduleDay).hour();
                      const minute = moment(scheduleDay).minute();
                      const newDate = moment(date).set('hour', hour).set('minute', minute).toDate();
                      setScheduleDay(newDate);
                    },
                  })}
                />
                <Flex mt='xs' direction='row' justify={'space-between'} align='flex-end'>
                  <TimeInput
                    w='100%'
                    label='Custom Time'
                    size='sm'
                    value={moment(scheduleDay).format('HH:mm')}
                    onChange={(event) => {
                      const value = event.currentTarget.value; // Format is HH:MM
                      const hour = parseInt(value.split(':')[0]);
                      const minute = parseInt(value.split(':')[1]);
                      const newDate = moment(scheduleDay)
                        .set('hour', hour)
                        .set('minute', minute)
                        .toDate();
                      setScheduleDay(newDate);
                    }}
                  />
                  <Tooltip label='Schedule for now' withArrow withinPortal>
                    <Flex>
                      <Button
                        size='xs'
                        mb='xs'
                        ml='sm'
                        variant='transparent'
                        color='red'
                        onClick={() => {
                          setShowSchedulePopup(false);
                          setScheduleDay(undefined);
                        }}
                      >
                        <IconX size='1rem' />
                      </Button>
                    </Flex>
                  </Tooltip>
                </Flex>
              </Popover.Dropdown>
            </Popover>
          </Flex>
        </Flex>
      </div>
    </Paper>
  );
});
