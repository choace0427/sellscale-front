import moment from "moment";
import {
  openedProspectIdState,
  openedBumpFameworksState,
  selectedBumpFrameworkState,
  currentConvoLiMessageState,
  currentConvoChannelState,
  currentConvoEmailMessageState,
  fetchingProspectIdState,
  tempHiddenProspectsState,
  selectedEmailSequenceStepState,
  selectedEmailThread,
  bumpFrameworkSelectedSubstatusState,
} from "@atoms/inboxAtoms";
import { userTokenState } from "@atoms/userAtoms";
import {
  Paper,
  Flex,
  Textarea,
  Text,
  Button,
  useMantineTheme,
  Group,
  ActionIcon,
  LoadingOverlay,
  Tooltip,
  Select,
  Box,
  Popover,
} from "@mantine/core";
import { getHotkeyHandler } from "@mantine/hooks";
import { hideNotification, showNotification } from "@mantine/notifications";
import {
  IconExternalLink,
  IconWriting,
  IconSend,
  IconChevronUp,
  IconChevronDown,
  IconSettings,
  IconArrowsDiagonalMinimize2,
  IconClock,
  IconArrowUp,
  IconCalendar,
  IconZzz,
  IconHourglass,
  IconX,
  IconPencil,
} from "@tabler/icons";
import {
  IconClock24,
  IconMessage2Cog,
  IconSettingsFilled,
  IconWand,
} from "@tabler/icons-react";
import { useQueryClient } from "@tanstack/react-query";
import { deleteAutoBumpMessage } from "@utils/requests/autoBumpMessage";
import { sendLinkedInMessage } from "@utils/requests/sendMessage";
import _, { debounce, get, set } from "lodash";
import {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";
import { useRecoilState, useRecoilValue } from "recoil";
import {
  BumpFramework,
  EmailSequenceStep,
  EmailThread,
  LinkedInMessage,
  Prospect,
} from "src";
import {
  generateAIEmailReply,
  generateAIFollowup,
} from "./InboxProspectConvoBumpFramework";
import AutoBumpFrameworkInfo from "@common/prospectDetails/AutoBumpFrameworkInfo";
import { ratio as fuzzratio } from "fuzzball";
import { sendEmail } from "@utils/requests/sendEmail";
import RichTextArea from "@common/library/RichTextArea";
import TextAreaWithAI from "@common/library/TextAreaWithAI";
import { JSONContent } from "@tiptap/react";
import DOMPurify from "dompurify";
import { postGenerateFollowupEmail } from "@utils/requests/emailMessageGeneration";
import { API_URL } from "@constants/data";
import { Calendar, DateTimePicker, TimeInput } from "@mantine/dates";

export default forwardRef(function InboxProspectConvoSendBox(
  props: {
    prospectId: number;
    linkedin_public_id: string;
    email: string;
    nylasMessageId?: string;
    scrollToBottom?: () => void;
    msgLoading?: boolean;
    minimizedSendBox: () => void;
    currentSubstatus?: string;
  },
  ref
) {
  useImperativeHandle(
    ref,
    () => {
      return {
        getAiGenerated: () => aiGenerated,
        setAiGenerated: setAiGenerated,
        getMessageDraft: () => messageDraft,
        setMessageDraft: (
          msg: string,
          bumpFramework?: {
            description?: string;
            id?: number;
            length?: string;
            title?: string;
          },
          accountResearch?: string[]
        ) => {
          // bumpFramework is no longer used because we want to show default bump framework and NOT the autogenerated one
          setMessageDraft(msg);
          if (accountResearch) {
            setBumpFramework((prev) => {
              if (!prev) {
                return prev;
              }
              return {
                ...prev,
                account_research: accountResearch,
              };
            });
          }
        },
        setAiMessage: (msg: string) => {
          setAiMessage(msg);
        },
        setBumpFrameworks: (bumpFrameworks: BumpFramework[]) => {
          setBumpFrameworks(bumpFrameworks);

          // Set the default bump framework
          // if (!selectedBumpFramework?.id) {
          //   if (bumpFrameworks.length > 0) {
          //     setBumpFramework(bumpFrameworks[0]);
          //     for (let i = 0; i < bumpFrameworks.length; i++) {
          //       if (bumpFrameworks[i].default) {
          //         setBumpFramework(bumpFrameworks[i]);
          //         break;
          //       }
          //     }
          //   }
          // }
        },
        setEmailSequenceSteps: (emailSequenceSteps: EmailSequenceStep[]) => {
          setEmailSequenceSteps(emailSequenceSteps);
          // Set the default bump framework
          if (emailSequenceSteps.length > 0) {
            setEmailSequenceStep(emailSequenceSteps[0]);
            for (let i = 0; i < emailSequenceSteps.length; i++) {
              if (emailSequenceSteps[i].default) {
                setEmailSequenceStep(emailSequenceSteps[i]);
                break;
              }
            }
          }
        },
      };
    },
    []
  );

  const theme = useMantineTheme();
  const queryClient = useQueryClient();
  const userToken = useRecoilValue(userTokenState);
  const [scheduleDay, setScheduleDay] = useState<Date | undefined>(undefined);
  const [showSchedulePopup, setShowSchedulePopup] = useState(false);
  const [snoozeDay, setSnoozeDay] = useState(
    moment(new Date()).add(4, "days").toDate()
  );
  const openedProspectId = useRecoilValue(openedProspectIdState);
  const openedOutboundChannel = useRecoilValue(currentConvoChannelState);
  const [fetchingProspectId, setFetchingProspectId] = useRecoilState(
    fetchingProspectIdState
  );
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [openBumpFrameworks, setOpenBumpFrameworks] = useRecoilState(
    openedBumpFameworksState
  );
  const [setOpenBumpFrameworksSubstatus, setSetOpenBumpFrameworksSubstatus] =
    useRecoilState(bumpFrameworkSelectedSubstatusState);
  const [selectedBumpFramework, setBumpFramework] = useRecoilState(
    selectedBumpFrameworkState
  ); // LinkedIn
  const [selectedEmailSequenceStep, setEmailSequenceStep] = useRecoilState(
    selectedEmailSequenceStepState
  ); // Email
  const [currentConvoLiMessages, setCurrentConvoLiMessages] = useRecoilState(
    currentConvoLiMessageState
  );
  const [currentConvoEmailMessages, setCurrentConvoEmailMessages] =
    useRecoilState(currentConvoEmailMessageState);
  const [currentConvoEmailThread, setCurrentConvoEmailThread] =
    useRecoilState(selectedEmailThread);

  const [tempHiddenProspects, setTempHiddenProspects] = useRecoilState(
    tempHiddenProspectsState
  );

  const [bumpFrameworks, setBumpFrameworks] = useState<BumpFramework[]>([]);
  const [emailSequenceSteps, setEmailSequenceSteps] = useState<
    EmailSequenceStep[]
  >([]);
  const [replyLabel, setReplyLabel] = useState(props.currentSubstatus);
  // We use this to store the value of the text area
  const [messageDraft, _setMessageDraft] = useState("");
  // We use this to store the raw value of the rich text editor
  const messageDraftRichRaw = useRef<JSONContent | string>();

  // We use this to set the value of the text area (for both rich text and normal text)
  const setMessageDraft = (value: string) => {
    messageDraftRichRaw.current = value;
    _setMessageDraft(value);
  };
  // For email we have to use this ref instead, otherwise the textbox does a weird refocusing.
  const messageDraftEmail = useRef("");

  const [aiMessage, setAiMessage] = useState("");
  const [aiGenerated, setAiGenerated] = useState(false);
  const [msgLoading, setMsgLoading] = useState(props.msgLoading || false);

  const sendMessage = async () => {
    setMsgLoading(true);

    // Delete the auto bump message if it exists
    await deleteAutoBumpMessage(userToken, props.prospectId);

    // Hack to update the prospect list to temp show they're in purgatory
    setTempHiddenProspects(tempHiddenProspects.concat([props.prospectId]));

    if (openedOutboundChannel === "LINKEDIN") {
      const msg = messageDraft;
      setMessageDraft("");
      showNotification({
        id: "send-linkedin-message",
        title: scheduleDay ? "Scheduling message..." : "Sending message ...",
        message: "",
        color: "green",
        autoClose: 3000,
      });
      setTimeout(() => setFetchingProspectId(-1), 15000);

      setFetchingProspectId(openedProspectId);
      sendLinkedInMessage(
        userToken,
        props.prospectId,
        msg,
        aiGenerated,
        undefined,
        selectedBumpFramework?.id,
        selectedBumpFramework?.title,
        selectedBumpFramework?.description,
        selectedBumpFramework?.bump_length,
        selectedBumpFramework?.account_research,
        snoozeDay,
        scheduleDay
      ).then(() => {
        queryClient.refetchQueries({
          queryKey: [
            `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
          ],
        });
      });
      if (true) {
        let yourMessage = _.cloneDeep(currentConvoLiMessages || [])
          .reverse()
          .find((msg) => msg.connection_degree === "You");
        if (yourMessage) {
          yourMessage.message = msg;
          yourMessage.date = new Date().toUTCString();
          yourMessage.ai_generated = false;
          setCurrentConvoLiMessages([
            ...(currentConvoLiMessages || []),
            yourMessage,
          ]);
        } else {
          queryClient.refetchQueries({
            queryKey: [
              `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
            ],
          });
        }
        showNotification({
          id: "send-linkedin-message",
          title: scheduleDay ? "Message Scheduled" : "Message Sent",
          message: "",
          color: "green",
        });
      } else {
        showNotification({
          id: "send-linkedin-message-error",
          title: "Error",
          message: "Failed to send message. Please try again later.",
          color: "red",
          autoClose: false,
        });
      }
    } else {
      if (
        currentConvoEmailMessages === undefined ||
        currentConvoEmailMessages.length === 0
      ) {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Please select an email thread",
          color: "red",
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }
      const msg = messageDraftEmail.current;
      if (msg.length === 0) {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Please enter a message",
          color: "red",
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }

      // Get the last message
      const replyToMessageID =
        currentConvoEmailMessages[currentConvoEmailMessages.length - 1]
          .nylas_message_id;
      const result = await sendEmail(
        userToken,
        props.prospectId,
        `Re: ${currentConvoEmailThread?.subject}`,
        msg,
        aiGenerated,
        replyToMessageID
      );
      if (result.status === "success") {
        let yourMessage = _.cloneDeep(currentConvoEmailMessages || [])
          .reverse()
          .find((msg) => msg.from_sdr);
        if (yourMessage) {
          yourMessage.body = msg;
          yourMessage.date_received = new Date().toUTCString();
          yourMessage.ai_generated = false;
          setCurrentConvoEmailMessages([
            ...(currentConvoEmailMessages || []),
            yourMessage,
          ]);
        } else {
          queryClient.refetchQueries({
            queryKey: [
              `query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`,
            ],
          });
        }
        messageDraftEmail.current = "";
        messageDraftRichRaw.current = "";
        setMessageDraft("");
      } else {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Failed to send message. Please try again later.",
          color: "red",
          autoClose: false,
        });
      }
    }

    setMsgLoading(false);
    setAiGenerated(false);
    setTimeout(() => props.scrollToBottom && props.scrollToBottom(), 100);
  };

  // If messageDraft is cleared, odds are that the AI generated message was cleared, and the new message is likely not to be AI generated
  useEffect(() => {
    checkFuzz(messageDraft, aiMessage);
  }, [messageDraft, aiMessage]);

  const checkFuzz = useCallback(
    debounce((message, aiMessage) => {
      const ratio = fuzzratio(message, aiMessage);
      // ratio > 5 && setAiGenerated(true);
      // ratio <= 5 && setAiGenerated(false);
      setAiGenerated(true);
    }, 200),
    []
  );

  const smartGenerate = async () => {
    setMsgLoading(true);
    if (openedOutboundChannel === "LINKEDIN") {
      const result = fetch(
        `${API_URL}/li_conversation/prospect/generate_smart_response`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${userToken}`,
          },
          body: JSON.stringify({
            prospect_id: props.prospectId,
          }),
        }
      )
        .then((res) => res.json())
        .then((j) => {
          const message = j["message"];

          setMessageDraft(message);
          setAiMessage(message);
          setBumpFramework(j["bump_framework"]);
          setAiGenerated(true);

          showNotification({
            id: "generate-linkedin-message",
            title: "Generated message",
            message: "",
            color: "green",
            autoClose: 3000,
          });
        })
        .catch((e) => {
          showNotification({
            id: "generate-linkedin-message-error",
            title: "Error",
            message: "Failed to generate message",
            color: "red",
            autoClose: 3000,
          });
        })
        .finally(() => {
          setMsgLoading(false);
        });
    }
  };

  useEffect(() => {
    if (replyLabel !== props.currentSubstatus) {
      setReplyLabel(props.currentSubstatus);
    }
  }, [props.currentSubstatus]);

  console.log({ bumpFrameworks });
  const replyLabels = useMemo(() => {
    const labels = new Set<string>();

    bumpFrameworks.forEach((i) => labels.add(i.substatus));

    return Array.from(labels);
  }, [bumpFrameworks]);
  return (
    <Paper
      shadow="sm"
      withBorder
      radius={theme.radius.md}
      sx={{
        display: "flex",
        flexDirection: "column",
        flexWrap: "nowrap",
        position: "relative",
      }}
      pb={8}
      mah={500}
    >
      <LoadingOverlay visible={msgLoading} />
      <div
        style={{
          flexBasis: "15%",
          backgroundColor: "#25262b",
          borderTopLeftRadius: theme.radius.md,
          borderTopRightRadius: theme.radius.md,
        }}
      >
        <Group spacing={0} position="apart">
          <Flex wrap="nowrap" align="center">
            <Text color="white" fz={14} fw={500} pl={15} pt={5}>
              {openedOutboundChannel === "LINKEDIN"
                ? "Message via LinkedIn"
                : "Reply via Email"}
            </Text>
            <Text
              pl={10}
              pt={5}
              size="xs"
              fs="italic"
              color="gray.3"
              component="a"
              target="_blank"
              rel="noopener noreferrer"
              href={
                openedOutboundChannel === "LINKEDIN"
                  ? `https://www.linkedin.com/in/${props.linkedin_public_id}`
                  : `mailto:${props.email}`
              }
            >
              {openedOutboundChannel === "LINKEDIN"
                ? `linkedin.com/in/${_.truncate(props.linkedin_public_id, {
                    length: 20,
                  })}`
                : props.email}{" "}
              <IconExternalLink size="0.65rem" />
            </Text>
          </Flex>
          {true && ( // TODO: Added chat box expanding
            <div style={{ paddingRight: 5 }}>
              <ActionIcon
                color="gray.0"
                size="lg"
                variant="transparent"
                onClick={props.minimizedSendBox}
              >
                <IconChevronDown size="1rem" />
              </ActionIcon>
            </div>
          )}
        </Group>
      </div>
      <div
        style={{
          flexBasis: "85%",
          position: "relative",
          paddingLeft: 10,
          paddingRight: 10,
        }}
      >
        <Flex justify={"space-between"} mt={10} gap={"xs"} >
          <Flex align={"center"} gap={"xs"} w='35%'>
            <Text fw={700} fz={"10px"} color="gray.6" w='35%'>
              Reply label
            </Text>
            <Select
              w='65%'
              size="xs"
              onChange={(val) => setReplyLabel(val || "")}
              value={replyLabel}
              withinPortal
              data={replyLabels.filter(label => label).map((label) => ({
                value: label,
                label: label?.replaceAll("ACTIVE_CONVO_", "").replaceAll("_", " ").toLowerCase(),
              }))}
            />
          </Flex>
          <Flex gap={"xs"} align={"center"} w='70%'>
            {/* only show for linkedin */}
            <Text fw={700} fz={"10px"} color="gray.6" w="25%">
              AI Response
            </Text>
            <Flex align={"center"} pos={"relative"} w='75%'>
              <Select
                rightSection={
                  <Tooltip
                    label={
                      selectedBumpFramework
                        ? `Manage '${selectedBumpFramework.title}'`
                        : `Configure Msg Gen`
                    }
                    withArrow
                  >
                    <Button
                      variant="outline"
                      color="gray.8"
                      size="xs"
                      w={'100%'}
                      radius={0}
                      sx={(theme) => ({
                        border: "none",
                        borderLeft: `1px solid ${theme.colors.gray[4]}`,
                        paddingLeft: 4,
                        paddingRight: 4,
                      })}
                      onClick={() => {
                        setOpenBumpFrameworks(true);
                      }}
                    >
                      {selectedBumpFramework ? (
                        <IconSettingsFilled size="0.8rem" />
                      ) : (
                        <IconSettings size="0.8rem" />
                      )}
                    </Button>
                  </Tooltip>
                }
                withinPortal
                placeholder={
                  bumpFrameworks.length > 0
                    ? "Select Framework"
                    : "No Frameworks"
                }
                size="xs"
                disabled={
                  (openedOutboundChannel === "LINKEDIN" &&
                    (bumpFrameworks === undefined ||
                      bumpFrameworks?.length === 0)) ||
                  (openedOutboundChannel != "LINKEDIN" &&
                    (emailSequenceSteps === undefined ||
                      emailSequenceSteps?.length === 0))
                }
                data={
                  openedOutboundChannel === "LINKEDIN"
                    ? bumpFrameworks.length > 0
                      ? bumpFrameworks
                          .sort((a: BumpFramework, b: BumpFramework) => {
                            return a.title.localeCompare(b.title);
                          })
                          .filter((i) => {
                            if (!replyLabel) {
                              return i;
                            }

                            return i.substatus === replyLabel;
                          })
                          .map((bf: BumpFramework) => {
                            let title = bf.title;
                            if (
                              bf.overall_status === "ACCEPTED" ||
                              bf.overall_status === "BUMPED"
                            ) {
                              title = "🟨 (seq): " + title;
                            }

                            return {
                              value: bf.id + "",
                              label: title,
                            };
                          })
                      : []
                    : emailSequenceSteps?.length > 0
                    ? emailSequenceSteps.map((step: EmailSequenceStep) => {
                        return {
                          value: step.id + "",
                          // label: (step.default ? "🟢 " : "⚪️ ") + step.title,
                          label: step.title,
                        };
                      })
                    : []
                }
                // styles={{
                //   input: {
                //     borderColor: "black",
                //     borderRight: "0",
                //     borderLeft: "0",
                //   },
                //   dropdown: { minWidth: 250 },
                // }}
                onChange={(value) => {
                  if (openedOutboundChannel === "LINKEDIN") {
                    const selected = bumpFrameworks.find(
                      (bf) => bf.id === parseInt(value as string)
                    );
                    if (selected) {
                      setBumpFramework(selected);
                      setReplyLabel(selected.substatus);
                    }

                    const substatus =
                      bumpFrameworks.length > 0
                        ? bumpFrameworks[0].substatus
                        : undefined;
                    setSetOpenBumpFrameworksSubstatus(substatus);
                  } else if (openedOutboundChannel === "EMAIL") {
                    const selected = emailSequenceSteps.find(
                      (step) => step.id === parseInt(value as string)
                    );
                    if (selected) {
                      setEmailSequenceStep(selected);
                    }
                  }
                }}
                value={
                  selectedBumpFramework
                    ? selectedBumpFramework.id + ""
                    : undefined
                }
              />
            </Flex>

            <Button
              leftIcon={<IconPencil size="1rem" />}
              variant="outline"
              color="gray.6"
              sx={{
                "&[data-disabled]": {
                  backgroundColor: "white",
                  border: "1px solid black",
                  pointerEvents: "all",
                },
              }}
              size="xs"
              disabled={
                (openedOutboundChannel === "LINKEDIN" &&
                  (bumpFrameworks === undefined ||
                    bumpFrameworks?.length === 0)) ||
                (openedOutboundChannel != "LINKEDIN" &&
                  (emailSequenceSteps === undefined ||
                    emailSequenceSteps?.length === 0))
              }
              onClick={async () => {
                setMsgLoading(true);
                if (openedOutboundChannel === "LINKEDIN") {
                  const result = await generateAIFollowup(
                    userToken,
                    props.prospectId,
                    selectedBumpFramework
                  );
                  setMessageDraft(result.msg);
                  setAiMessage(result.msg);
                  setAiGenerated(result.aiGenerated);
                } else if (openedOutboundChannel === "EMAIL") {
                  if (!currentConvoEmailThread) {
                    showNotification({
                      id: "send-email-message-error",
                      title: "Error",
                      message: "Please select an email thread",
                      color: "red",
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }
                  const result = await postGenerateFollowupEmail(
                    userToken,
                    props.prospectId,
                    currentConvoEmailThread.nylas_thread_id,
                    selectedEmailSequenceStep?.id || null,
                    null
                  );
                  // Clean the result
                  const email_body = result.data.email_body;
                  if (!email_body) {
                    showNotification({
                      id: "generate-email-message-error",
                      title: "Error",
                      message: "Failed to generate message. Please try again.",
                      color: "red",
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }
                  const message = email_body.completion;
                  messageDraftEmail.current = message;
                  setMessageDraft(message);
                  setAiMessage(message);
                  setAiGenerated(true);
                }
                setMsgLoading(false);
              }}
            >
              Generate {openedOutboundChannel === "LINKEDIN" ? "" : "Email"}
            </Button>
          </Flex>
        </Flex>

        <Box pos={"relative"}>
          {openedOutboundChannel === "LINKEDIN" ? (
            <Textarea
              minRows={5}
              maxRows={8}
              mt="xs"
              color="gray"
              placeholder="Your message..."
              value={messageDraft}
              onChange={(event) => _setMessageDraft(event.currentTarget.value)}
              onKeyDown={getHotkeyHandler([
                [
                  "mod+Enter",
                  () => {
                    sendMessage();
                  },
                ],
              ])}
            />
          ) : (
            <Box mt="xs">
              <RichTextArea
                onChange={(value, rawValue) => {
                  messageDraftRichRaw.current = rawValue;
                  messageDraftEmail.current = value;
                }}
                value={messageDraftRichRaw.current}
                height={110}
              />
            </Box>
          )}

          {aiGenerated && (
            <AutoBumpFrameworkInfo
              useBumpFramework={selectedBumpFramework !== undefined}
              bump_title={selectedBumpFramework?.title || "None"}
              bump_description={
                selectedBumpFramework?.description || "No framework"
              }
              bump_length={selectedBumpFramework?.bump_length || "No length"}
              account_research_points={
                selectedBumpFramework?.account_research || []
              }
              bump_number_sent={selectedBumpFramework?.etl_num_times_used}
              bump_number_converted={
                selectedBumpFramework?.etl_num_times_converted
              }
            />
          )}
        </Box>

        <Flex align="center" mt="xs" direction="row" justify={"space-between"}>
          {openedOutboundChannel === "LINKEDIN" && (
            <Tooltip withArrow position="bottom" label="Smart Generate with AI">
              <Button
                leftIcon={<IconWand size="0.8rem" />}
                color="grape"
                size="xs"
                sx={{ borderRadius: "4px" }}
                onClick={() => {
                  showNotification({
                    id: "generate-linkedin-message",
                    title: "Generating message ...",
                    message: "",
                    color: "blue",
                    autoClose: 3000,
                  });
                  smartGenerate();
                }}
              >
                Smart Generate
              </Button>
            </Tooltip>
          )}
          <Flex align="center" mt="xs" direction="row" justify={"end"}>
            <Popover
              position="bottom"
              withArrow
              shadow="md"
              trapFocus
              opened={showCalendarPopup}
            >
              <Popover.Target>
                <Tooltip label="Set a custom snooze day" withArrow withinPortal>
                  <Flex>
                    <Button
                      onClick={() => setShowCalendarPopup((v) => !v)}
                      size="xs"
                      sx={{
                        borderTopRightRadius: 0,
                        borderBottomRightRadius: 0,
                      }}
                    >
                      <IconZzz size={"1rem"} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>
              <Popover.Dropdown>
                <Calendar
                  placeholder={"Select a date"}
                  minDate={moment(new Date()).add(1, "days").toDate()}
                  getDayProps={(date) => ({
                    selected: moment(snoozeDay).isSame(date, "day"),
                    onClick: () => {
                      setShowCalendarPopup(false);
                      setSnoozeDay(date);
                    },
                  })}
                />
              </Popover.Dropdown>
            </Popover>

            <Button
              size="xs"
              sx={{
                borderTopRightRadius: 0,
                borderBottomRightRadius: 0,
                borderTopLeftRadius: 0,
                borderBottomLeftRadius: 0,
                borderLeft: `1px solid #fff`,
                borderRight: `1px solid #fff`,
              }}
              onClick={() => sendMessage()}
              styles={(theme) => ({
                rightIcon: {
                  borderLeft: `1px solid ${theme.white}`,
                  marginLeft: "0.5rem",
                  paddingLeft: "0.25rem",
                },
              })}
            >
              {scheduleDay
                ? "Schedule for [" +
                  moment(scheduleDay).format("MMM Do h:mmA") +
                  "] "
                : "Send"}{" "}
              and Snooze for {moment(snoozeDay).diff(new Date(), "days") + 1}{" "}
              days
            </Button>
            <Popover
              position="bottom"
              withArrow
              shadow="md"
              trapFocus
              opened={showSchedulePopup}
            >
              <Popover.Target>
                <Tooltip
                  label="Schedule a send time into the future"
                  withArrow
                  withinPortal
                >
                  <Flex>
                    <Button
                      onClick={() => setShowSchedulePopup((v) => !v)}
                      size="xs"
                      sx={{ borderTopLeftRadius: 0, borderBottomLeftRadius: 0 }}
                    >
                      <IconClock24 size={"1rem"} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>

              <Popover.Dropdown>
                <Calendar
                  placeholder={"Select a date"}
                  minDate={moment(new Date()).add(1, "days").toDate()}
                  getDayProps={(date) => ({
                    selected: moment(scheduleDay).isSame(date, "day"),
                    onClick: () => {
                      // Preserve the time
                      const hour = moment(scheduleDay).hour();
                      const minute = moment(scheduleDay).minute();
                      const newDate = moment(date)
                        .set("hour", hour)
                        .set("minute", minute)
                        .toDate();
                      setScheduleDay(newDate);
                    },
                  })}
                />
                <Flex
                  mt="xs"
                  direction="row"
                  justify={"space-between"}
                  align="flex-end"
                >
                  <TimeInput
                    w="100%"
                    label="Custom Time"
                    size="sm"
                    value={moment(scheduleDay).format("HH:mm")}
                    onChange={(event) => {
                      const value = event.currentTarget.value; // Format is HH:MM
                      const hour = parseInt(value.split(":")[0]);
                      const minute = parseInt(value.split(":")[1]);
                      const newDate = moment(scheduleDay)
                        .set("hour", hour)
                        .set("minute", minute)
                        .toDate();
                      setScheduleDay(newDate);
                    }}
                  />
                  <Tooltip label="Schedule for now" withArrow withinPortal>
                    <Flex>
                      <Button
                        size="xs"
                        mb="xs"
                        ml="sm"
                        variant="transparent"
                        color="red"
                        onClick={() => {
                          setShowSchedulePopup(false);
                          setScheduleDay(undefined);
                        }}
                      >
                        <IconX size="1rem" />
                      </Button>
                    </Flex>
                  </Tooltip>
                </Flex>
              </Popover.Dropdown>
            </Popover>
          </Flex>
        </Flex>
      </div>
    </Paper>
  );
});
